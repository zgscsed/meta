<!--
 * Copyright (C) 2024 zgscsed. All rights reserved.
 * @filename: file name
 * @Author: zgscsed
 * @Date: 2024-02-07 20:33:00
 * @LastEditors: zgscsed
 * @LastEditTime: 2024-02-11 18:43:05
 * @Description: file content
-->
# 模板初识

- [模板初识](#模板初识)
  - [一、模板](#一模板)
    - [1.1 模板的概念](#11-模板的概念)
    - [1.2 函数模版](#12-函数模版)
    - [1.3 类模板](#13-类模板)
    - [1.4 模板的实例化](#14-模板的实例化)
    - [模板显示实例化语法](#模板显示实例化语法)
  - [模板参数](#模板参数)

## 一、模板
关键概念：参数化，模板，实例化
### 1.1 模板的概念

值和类型。
函数参数值是未知的，只有实际调用的时候才能确定值 -- 值的参数化。  
函数定义时不指定具体的类型，而是在函数调用时，根据传入的参数自动推断数据类型   -- 类型的参数化。

模板是一个函数或者类的描述，演化出具体的类或者函数。
模板是 C++ 中的泛型编程的基础。 使用模板可以定义类或函数的操作，并让用户指定这些操作应处理的具体类型，一般分为 **函数模板** 和**类模版**。

### 1.2 函数模版

函数模板创建了一个通用的函数，函数中的类型是一个虚拟类型代替，编译时更加传入的参数类型生成具体类型的函数。

语法如下所示例子：

```c++
template <typename T>
T add(T a, T b)
{
    return a + b;
}
```

template: 使用模板的关键字， 告诉编译器要使用模板  
typename: 定义形参的关键字，说明形参名为 类型 参数,   可以使用class关键字替换。  
模板形参不能为空，且需要在函数参数列表中出现。函数定义部分同普通函数，参数列表可以使用模板形参，也可以使用一般类型。


### 1.3 类模板

允许定义一个通用的类模板，使成员或者函数可以根据不同的数据类型参数化。

使用语法:

```c++
// 类模板语法例子
template <class T>
class MyClass
{
public:
    MyClass(T a, T b)
    {
        this->a = a;
        this->b = b;
    }
    T add()
    {
        return a + b;
    }
    T a;
    T b;
};
```

### 1.4 模板的实例化

前面也说了，模板只是一个描述，不是具体的实现，只有在模板实例化的时候才会生成具体的代码。函数模板实例化后生成真正的函数，类模板
实例化，只是完成了类的定义，具体成员函数，需要等使用到函数成员的时候才会实例化。  

模板实例化有两种方式：

- 隐式实例化：调用时不存在模板函数或者模板类实体时，编译器会根据指定的参数类型生成实体

- 显示实例化：开发者通过显示实例化声明的方式生成模板实体

模板实例化过程是在编译时进行的，因此模板的定义和实现必须放在头文件中，以便编译器编译时能够找到模板的定义。  

函数模板使用有两种方式：

- 隐式模板实参调用

- 显示模板实参调用

类模板则不存在这两种调用方式的区别，类模板使用必须要指定参数类型。
使用例子：

```c++
int TestTemplateInstantiation()
{
    int a = 1;
    int b = 2;
    double c = 1.1;
    double d = 2.2;
    std::cout << add(a, b) << std::endl; // 隐式实参调用
    std::cout << add(c, d) << std::endl; // 隐式实参调用
    std::cout << add<double>(a, b) << std::endl; // 显式实参调用
    std::cout << add<int>(c, d) << std::endl; // 显式实参调用

    MyClass<int> t(1, 2);
    std::cout << t.add() << std::endl;
    MyClass<double> t2(1.1, 2.2);
    std::cout << t2.add() << std::endl;
    return 0;
}
```

### 模板显示实例化语法

```c++

// template [函数返回类型] [函数模板名]<实际类型列表>（函数参数列表)

extern template int add<int>(int a, int b);

// template class [类模板名]<实际类型列表>
template class MyClass<int>;
```

## 模板参数

模板形参表中的参数类型有3种：类型参数、非类型参数、类模板类型的参数

非类型参数：
整型或者枚举型；
指针类型；
左值引用类型；
auto或者decltype(auto)（c++17支持auto类型）

类模板中可以为非类型模板参数提供默认值， 默认值只会定义一次，并且必须在模板形参列表右侧
如果模板参数都有默认值，那么可以声明一个实例时使用一对空的尖括号，这样编译器就知道说明了一个类模板。

在C++中，类模板的参数类型不会进行自动转换。这意味着当我们使用类模板时，
传递给模板的参数必须与定义模板时指定的参数类型完全相同或者可以通过显式地将其转换为正确的类型来匹配。

函数模板 自动类型推导时，一般不会对其函数参数 进行 自动类型转换(k可以指明使用模板函数，会自动推导)，普通函数会自动类型转换。

模板返回类型自动推导

```c++

template <typename T1, typename T2>
T1 add(T1 a, T2 b) {
    return a + b;
}

int add(int a, int b)
{
    return a + b;
}

add<>(1, 2.0);  // 强制使用模板
```